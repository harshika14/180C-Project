////only working code saturday 
package mockp;
////import java.util.*;
////import java.util.concurrent.*;
//
////public class MergeSort<N extends Comparable<N>> extends RecursiveTask<List<N>> {
////    private List<N> elements;
////
////    public MergeSort(List<N> elements) {
////        this.elements = elements;
////    }
////
////    @Override
////    protected List<N> compute() {
////        if(this.elements.size() <= 1)
////            return this.elements;
////        else {
////            final int pivot = this.elements.size() / 2;
////            System.out.println(pivot);
////            MergeSort<N> leftTask = new MergeSort<N>(this.elements.subList(0, pivot));
////            MergeSort<N> rightTask = new MergeSort<N>(this.elements.subList(pivot, this.elements.size()));
////
////            leftTask.fork();
////            rightTask.fork();
////
////            List<N> left = leftTask.join();
////            List<N> right = rightTask.join();
////
////            merge(left, right);
////            return this.elements;
////        }
////    }
////
////    private void merge(List<N> left, List<N> right) {
////        int leftIndex = 0;
////        int rightIndex = 0;
////        while(leftIndex < left.size()) {
////            if(rightIndex == 0) {
////                if( left.get(leftIndex).compareTo(right.get(rightIndex)) > 0 ) {
////                    swap(left, leftIndex++, right, rightIndex++);
////                } else {
////                    leftIndex++;
////                }
////            } else {
////                if( right.get(0).compareTo(right.get(rightIndex)) < 0 ) {
////                    swap(left, leftIndex++, right, 0);
////                } else {
////                    swap(left, leftIndex++, right, rightIndex++);
////                }
////            }
////        }
////
////        if(rightIndex < right.size() && rightIndex != 0)
////            merge(right.subList(0, rightIndex), right.subList(rightIndex, right.size()));
////    }
////
////    private void swap(List<N> left, int leftIndex, List<N> right, int rightIndex) {
////        //N leftElement = left.get(leftIndex);
////        left.set(leftIndex, right.set(rightIndex, left.get(leftIndex)));
////    }
////
////    public static void main(String[] args) { 
////    	long stime=java.lang.System.currentTimeMillis() ;
////        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
////        
////        
////        List<Integer> result = forkJoinPool.invoke(new MergeSort<Integer>(new ArrayList<>(Arrays.asList(1,3,5,7,2,4,5,6,7,8,7,6,8))));
////        long etime=java.lang.System.currentTimeMillis() ;
////        long a= etime-stime;
////        System.out.println("result: " + result+"time taken " + a);
////    } 
////} 
//
//
//
//
//
//
//
//
//
////trial
//
//
//import java.util.*;
//import java.util.concurrent.*;
//
//public class MergeSort<N extends Comparable<N>> extends RecursiveAction {
//    private List<N> elements;
//
//    public MergeSort(List<N> elements) {
//        this.elements = elements;
//    }
//
//   
//       
//    	 @Override
//       protected List<N> compute() {
//           if(this.elements.size() <= 1)
//               return this.elements;
//           else {
//               final int pivot = this.elements.size() / 2;
//               System.out.println(pivot);
//               MergeSort<N> leftTask = new MergeSort<N>(this.elements.subList(0, pivot));
//               MergeSort<N> rightTask = new MergeSort<N>(this.elements.subList(pivot, this.elements.size()));
//   
//               leftTask.fork();
//               rightTask.fork();
//   
//               List<N> left = leftTask.join();
//               List<N> right = rightTask.join();
//   
//               merge(left, right);
//               return this.elements;
//           } }
////       
//    	
//        
//    
//
//    private void merge(List<N> left, List<N> right) {
//        int leftIndex = 0;
//        int rightIndex = 0;
//        while(leftIndex < left.size()) {
//            if(rightIndex == 0) {
//                if( left.get(leftIndex).compareTo(right.get(rightIndex)) > 0 ) {
//                    swap(left, leftIndex++, right, rightIndex++);
//                } else {
//                    leftIndex++;
//                }
//            } else {
//                if( right.get(0).compareTo(right.get(rightIndex)) < 0 ) {
//                    swap(left, leftIndex++, right, 0);
//                } else {
//                    swap(left, leftIndex++, right, rightIndex++);
//                }
//            }
//        }
//
//        if(rightIndex < right.size() && rightIndex != 0)
//            merge(right.subList(0, rightIndex), right.subList(rightIndex, right.size()));
//    }
//
//    private void swap(List<N> left, int leftIndex, List<N> right, int rightIndex) {
//        //N leftElement = left.get(leftIndex);
//        left.set(leftIndex, right.set(rightIndex, left.get(leftIndex)));
//    }
//
//    public static void main(String[] args) {
//        List<Integer> myList = new ArrayList<Integer>(Arrays.asList(1,3,5,7,2));
//        MergeSort<Integer> msort = new MergeSort<Integer>(myList);
//        ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
//        forkJoinPool.invoke(msort);
//        for (int i=0; i<5; i++){
//            System.out.println(myList.get(i));
//        }
//    }
//} 


import java.util.*;
import java.util.concurrent.*;

public class MergeSort<N extends Comparable> extends RecursiveAction {
    private List<N> elements;

    public MergeSort(List<N> elements) {
        this.elements = elements;
    }

    @Override
    protected void compute() {
        if(this.elements.size() <= 1)
            System.out.println("List size less than 1 dont know reason of this line ");
        	
        else {
            final int pivot = this.elements.size() / 2;
            //System.out.println(pivot);
            MergeSort<N> leftTask = new MergeSort<N>(this.elements.subList(0, pivot));
            MergeSort<N> rightTask = new MergeSort<N>(this.elements.subList(pivot, this.elements.size()));

//            leftTask.fork();
//            rightTask.fork();

//             leftTask.join();
//            List<N> right = rightTask.join();
            invokeAll(leftTask,rightTask);

            merge(leftTask.elements, rightTask.elements);
            //return this.elements;
        }
    }

    private void merge(List<N> left, List<N> right) {
        int leftIndex = 0;
        int rightIndex = 0;
        while(leftIndex < left.size()) {
            if(rightIndex == 0) {
                if( left.get(leftIndex).compareTo(right.get(rightIndex)) > 0 ) {
                    swap(left, leftIndex++, right, rightIndex++);
                } else {
                    leftIndex++;
                }
            } else {
                if( right.get(0).compareTo(right.get(rightIndex)) < 0 ) {
                    swap(left, leftIndex++, right, 0);
                } else {
                    swap(left, leftIndex++, right, rightIndex++);
                }
            }
        }

        if(rightIndex < right.size() && rightIndex != 0)
            merge(right.subList(0, rightIndex), right.subList(rightIndex, right.size()));
    }

    private void swap(List<N> left, int leftIndex, List<N> right, int rightIndex) {
        //N leftElement = left.get(leftIndex);
        left.set(leftIndex, right.set(rightIndex, left.get(leftIndex)));
    }

    public static void main(String[] args) {
       
        
        List<Integer> myList = new ArrayList<Integer>(Arrays.asList(1,3,5,7,2,6,3));
      MergeSort<Integer> msort = new MergeSort<Integer>(myList);
      ForkJoinPool forkJoinPool = ForkJoinPool.commonPool();
      forkJoinPool.invoke(msort);
      for (int i=0; i<7; i++){
          System.out.println(myList.get(i));
      }
    }
}




